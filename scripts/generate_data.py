import pandas as pd
import numpy as np
from faker import Faker
from datetime import timedelta, datetime
import random
import os
import sqlite3

fake = Faker()
np.random.seed(42)

CONFIG = {
    "NUM_WEEKS": 156,  # ~3 years
    "START_DATE": datetime(2022, 1, 1),
    "PLANS": {"Basic": 29, "Pro": 99, "Enterprise": 299},
    "MARKETING_CHANNELS": ["Google Ads", "LinkedIn", "SEO", "Facebook Ads"],
    "COUNTRIES": ["USA", "Canada", "UK", "Germany", "France", "Australia", "India", "Brazil", "Japan", "Other"],
    "SUBSCRIPTION_EVENT_TYPES": ["trial_start", "trial_conversion", "upgrade", "downgrade", "cancellation_request", "cancellation_processed"],
    "SUPPORT_TICKET_STATUSES": ["Open", "In Progress", "Pending Customer Response", "Resolved", "Closed"],
    "SUPPORT_TICKET_PRIORITIES": ["Low", "Medium", "High", "Urgent"],
    "SUPPORT_TICKET_CHANNELS": ["Email", "Chat", "Phone", "Forum"],
    "SUPPORT_TICKET_ISSUE_TYPES": ["Billing Inquiry", "Technical Glitch", "Feature Request", "Password Reset", "How-to Question", "Bug Report"],
    "TRIAL_PERIOD_DAYS": 14,
    "DATA_OUTPUT_PATH": "data/raw",
    "SQLITE_DB_PATH": "data/sqlite/saas_analytics.db"
}

# Simulate weekly cohorts
def simulate_weekly_signups():
    """
    Simulates weekly customer signups.
    Output DataFrame Schema:
    - customer_id (int): Unique identifier for the customer.
    - signup_date (date): Date of customer signup.
    - plan (str): Subscribed plan (Basic, Pro, Enterprise).
    - marketing_channel (str): Channel through which customer was acquired.
    - country (str): Customer's country.
    - churn_date (date, optional): Date of customer churn, None if active.
    """
    records = []
    customer_id = 1
    for week in range(CONFIG["NUM_WEEKS"]):
        # Seasonality: more signups in Q1 and Q4
        base_signups = 50 + 30 * np.sin(2 * np.pi * week / 52)
        growth = 1 + (week / CONFIG["NUM_WEEKS"]) * 0.75  # gradual growth
        n_signups = int(np.random.poisson(base_signups * growth))
        
        for _ in range(n_signups):
            signup_date = CONFIG["START_DATE"] + timedelta(weeks=week)
            plan = random.choices(list(CONFIG["PLANS"].keys()), weights=[0.6, 0.3, 0.1])[0]
            channel = random.choice(CONFIG["MARKETING_CHANNELS"])
            country = random.choice(CONFIG["COUNTRIES"])
            churn_weeks = int(np.random.exponential(scale=52)) # Average 1 year
            churn_date = signup_date + timedelta(weeks=churn_weeks)
            
            max_simulation_date = CONFIG["START_DATE"] + timedelta(weeks=CONFIG["NUM_WEEKS"] + 52)
            if churn_date > max_simulation_date:
                 churn_date = max_simulation_date
            
            if churn_date > (CONFIG["START_DATE"] + timedelta(weeks=CONFIG["NUM_WEEKS"])):
                 if random.random() < 0.7:
                    churn_date = None

            records.append({
                "customer_id": customer_id,
                "signup_date": signup_date.date(),
                "plan": plan,
                "marketing_channel": channel,
                "country": country,
                "churn_date": churn_date.date() if churn_date else None
            })
            customer_id += 1
    return pd.DataFrame(records)

# Simulate marketing spend + CAC per channel
def simulate_marketing_data():
    """
    Simulates weekly marketing spend and customer acquisition cost (CAC) per channel.
    Output DataFrame Schema:
    - week (int): Week number from the start of simulation.
    - week_start (date): Start date of the week.
    - channel (str): Marketing channel.
    - ad_spend (float): Amount spent on ads for the channel in that week.
    - leads (int): Number of leads generated by the channel in that week.
    - CAC (float): Customer Acquisition Cost for the channel in that week.
    """
    records = []
    for week in range(CONFIG["NUM_WEEKS"]):
        week_date = CONFIG["START_DATE"] + timedelta(weeks=week)
        for channel in CONFIG["MARKETING_CHANNELS"]:
            spend = np.random.normal(loc=5000, scale=1000)
            leads = int(np.random.poisson(50 + week * 0.5))
            cac = spend / max(leads, 1)
            records.append({
                "week": week,
                "week_start": week_date.date(),
                "channel": channel,
                "ad_spend": round(max(spend, 1000), 2),
                "leads": leads,
                "CAC": round(cac, 2)
            })
    return pd.DataFrame(records)

# Simulate revenue per customer per week
def simulate_weekly_revenue(customers_df):
    """
    Simulates weekly Monthly Recurring Revenue (MRR) per customer.
    Output DataFrame Schema:
    - customer_id (int): Unique identifier for the customer.
    - week (int): Week number from the start of simulation.
    - week_start (date): Start date of the week.
    - plan (str): Customer's plan for that week.
    - MRR (float): Monthly Recurring Revenue from the customer for that week.
    """
    records = []
    for _, row in customers_df.iterrows():
        signup = datetime.strptime(str(row.signup_date), "%Y-%m-%d")
        churn = datetime.strptime(str(row.churn_date), "%Y-%m-%d") if pd.notnull(row.churn_date) else CONFIG["START_DATE"] + timedelta(weeks=CONFIG["NUM_WEEKS"])
        plan_price = CONFIG["PLANS"][row.plan]
        for week in range(CONFIG["NUM_WEEKS"]):
            week_date = CONFIG["START_DATE"] + timedelta(weeks=week)
            if signup <= week_date < churn:
                records.append({
                    "customer_id": row.customer_id,
                    "week": week,
                    "week_start": week_date.date(),
                    "plan": row.plan,
                    "MRR": plan_price
                })
    return pd.DataFrame(records)

# Simulate product engagement (logins, feature use)
def simulate_product_data(customers_df):
    """
    Simulates weekly product engagement for active customers.
    Output DataFrame Schema:
    - customer_id (int): Unique identifier for the customer.
    - week (int): Week number from the start of simulation.
    - week_start (date): Start date of the week.
    - sessions (int): Number of sessions for the customer in that week.
    - features_used (int): Number of distinct features used by the customer in that week.
    """
    records = []
    for week in range(CONFIG["NUM_WEEKS"]):
        week_date = CONFIG["START_DATE"] + timedelta(weeks=week)
        active_customers = customers_df[
            (pd.to_datetime(customers_df.signup_date) <= week_date) &
            ((pd.isnull(customers_df.churn_date)) | (pd.to_datetime(customers_df.churn_date) > week_date))
        ]
        for _, row in active_customers.iterrows():
            sessions = np.random.poisson(5)
            features_used = np.random.randint(1, 6)
            records.append({
                "customer_id": row.customer_id,
                "week": week,
                "week_start": week_date.date(),
                "sessions": sessions,
                "features_used": features_used
            })
    return pd.DataFrame(records)

# Simulate subscription changes (trials, upgrades, downgrades, cancellations)
def simulate_subscription_changes(customers_df):
    """
    Simulates subscription change events for customers.
    Output DataFrame Schema:
    - event_id (int): Unique identifier for the subscription event.
    - customer_id (int): Unique identifier for the customer.
    - event_date (date): Date of the subscription event.
    - event_type (str): Type of event (e.g., 'trial_start', 'upgrade').
    - old_plan (str, optional): Previous plan, None if new customer.
    - new_plan (str, optional): New plan, None if cancellation.
    - mrr_change (float): Change in MRR due to this event.
    """
    records = []
    event_id_counter = 1
    plan_tiers = list(CONFIG["PLANS"].keys())

    for _, customer in customers_df.iterrows():
        cust_id = customer.customer_id
        signup_dt = datetime.strptime(str(customer.signup_date), "%Y-%m-%d")
        initial_plan = customer.plan
        churn_dt = pd.to_datetime(customer.churn_date) if pd.notnull(customer.churn_date) else None
        current_plan = initial_plan
        current_mrr = CONFIG["PLANS"][current_plan]

        # Trial Start
        records.append({
            "event_id": event_id_counter, "customer_id": cust_id, "event_date": signup_dt.date(),
            "event_type": "trial_start", "old_plan": None, "new_plan": current_plan,
            "mrr_change": 0 
        })
        event_id_counter += 1

        conversion_date = signup_dt + timedelta(days=CONFIG["TRIAL_PERIOD_DAYS"])
        if churn_dt is None or conversion_date < churn_dt:
            records.append({
                "event_id": event_id_counter, "customer_id": cust_id, "event_date": conversion_date.date(),
                "event_type": "trial_conversion", "old_plan": "Trial", "new_plan": current_plan,
                "mrr_change": current_mrr
            })
            event_id_counter += 1
            last_event_date = conversion_date
        else: 
            if churn_dt: 
                records.append({
                    "event_id": event_id_counter, "customer_id": cust_id, "event_date": churn_dt.date(),
                    "event_type": "cancellation_processed", "old_plan": current_plan, "new_plan": None,
                    "mrr_change": 0 
                })
                event_id_counter += 1
            continue 

        for _ in range(random.randint(0, 2)):
            if churn_dt and last_event_date >= churn_dt - timedelta(days=30): 
                break
            
            potential_event_date = last_event_date + timedelta(days=random.randint(30, 365))
            if churn_dt and potential_event_date >= churn_dt:
                break
            if potential_event_date > CONFIG["START_DATE"] + timedelta(weeks=CONFIG["NUM_WEEKS"]):
                break

            action = random.choice(["upgrade", "downgrade"])
            current_plan_index = plan_tiers.index(current_plan)
            new_plan = None
            old_mrr = CONFIG["PLANS"][current_plan]

            if action == "upgrade" and current_plan_index < len(plan_tiers) - 1:
                new_plan = plan_tiers[current_plan_index + 1]
            elif action == "downgrade" and current_plan_index > 0:
                new_plan = plan_tiers[current_plan_index - 1]

            if new_plan:
                new_mrr = CONFIG["PLANS"][new_plan]
                records.append({
                    "event_id": event_id_counter, "customer_id": cust_id, "event_date": potential_event_date.date(),
                    "event_type": action, "old_plan": current_plan, "new_plan": new_plan,
                    "mrr_change": new_mrr - old_mrr
                })
                event_id_counter += 1
                current_plan = new_plan
                current_mrr = new_mrr
                last_event_date = potential_event_date
        
        if churn_dt:
            request_date = churn_dt - timedelta(days=random.randint(1, 14))
            if request_date < last_event_date : request_date = last_event_date + timedelta(days=1) 
            if request_date < churn_dt:
                records.append({
                    "event_id": event_id_counter, "customer_id": cust_id, "event_date": request_date.date(),
                    "event_type": "cancellation_request", "old_plan": current_plan, "new_plan": current_plan,
                    "mrr_change": 0
                })
                event_id_counter += 1

            records.append({
                "event_id": event_id_counter, "customer_id": cust_id, "event_date": churn_dt.date(),
                "event_type": "cancellation_processed", "old_plan": current_plan, "new_plan": None,
                "mrr_change": -current_mrr
            })
            event_id_counter += 1

    return pd.DataFrame(records)

# Simulate customer support tickets
def simulate_support_tickets(customers_df):
    """
    Simulates customer support tickets.
    Output DataFrame Schema:
    - ticket_id (int): Unique identifier for the support ticket.
    - customer_id (int): Unique identifier for the customer who raised the ticket.
    - creation_date (date): Date when the ticket was created.
    - resolution_date (date, optional): Date when the ticket was resolved, None if still open/pending.
    - status (str): Current status of the ticket (e.g., 'Open', 'Resolved').
    - priority (str): Priority of the ticket (e.g., 'Low', 'High').
    - issue_type (str): Category of the issue (e.g., 'Billing Inquiry', 'Bug Report').
    - channel (str): Channel through which the ticket was submitted (e.g., 'Email', 'Chat').
    """
    records = []
    ticket_id_counter = 1

    for _, customer in customers_df.iterrows():
        cust_id = customer.customer_id
        signup_dt = pd.to_datetime(customer.signup_date)
        churn_dt = pd.to_datetime(customer.churn_date) if pd.notnull(customer.churn_date) else CONFIG["START_DATE"] + timedelta(weeks=CONFIG["NUM_WEEKS"])
        
        num_tickets = np.random.poisson(1) 
        if num_tickets == 0 and random.random() < 0.3 : num_tickets = random.randint(1,3)

        for _ in range(num_tickets):
            if signup_dt >= churn_dt - timedelta(days=1):
                continue
            
            if (churn_dt - signup_dt).days <= 0:
                creation_dt = signup_dt 
            else:
                creation_dt = signup_dt + timedelta(days=random.randint(0, (churn_dt - signup_dt).days -1  ))
            
            status = random.choice(CONFIG["SUPPORT_TICKET_STATUSES"])
            resolution_dt = None
            if status in ["Resolved", "Closed"]:
                resolution_dt = creation_dt + timedelta(days=random.randint(0, 7), hours=random.randint(1,23))
                if resolution_dt > churn_dt and churn_dt is not None : resolution_dt = churn_dt 

            records.append({
                "ticket_id": ticket_id_counter,
                "customer_id": cust_id,
                "creation_date": creation_dt.date(),
                "resolution_date": resolution_dt.date() if resolution_dt else None,
                "status": status,
                "priority": random.choice(CONFIG["SUPPORT_TICKET_PRIORITIES"]),
                "issue_type": random.choice(CONFIG["SUPPORT_TICKET_ISSUE_TYPES"]),
                "channel": random.choice(CONFIG["SUPPORT_TICKET_CHANNELS"])
            })
            ticket_id_counter += 1
    return pd.DataFrame(records)

def simulate_calendar_table():
    """
    Generates a calendar table with week-level granularity.
    Output DataFrame Schema:
    - week_id (int): Unique identifier for the week (0-indexed).
    - week_start_date (date): Start date of the week (Monday).
    - week_end_date (date): End date of the week (Sunday).
    - month (int): Month number (1-12).
    - quarter (int): Quarter number (1-4).
    - year (int): Year.
    """
    records = []
    for week_num in range(CONFIG["NUM_WEEKS"]):
        week_start = CONFIG["START_DATE"] + timedelta(weeks=week_num)
        week_end = week_start + timedelta(days=6)
        records.append({
            "week_id": week_num,
            "week_start_date": week_start.date(),
            "week_end_date": week_end.date(),
            "month": week_start.month,
            "quarter": (week_start.month - 1) // 3 + 1,
            "year": week_start.year
        })
    return pd.DataFrame(records)

if __name__ == "__main__":
    output_path = CONFIG["DATA_OUTPUT_PATH"]
    os.makedirs(output_path, exist_ok=True)
    print(f"Ensuring output directory exists: {output_path}")

    print("\nGenerating datasets...")

    df_calendar = simulate_calendar_table()
    df_calendar.to_csv(os.path.join(output_path, "calendar.csv"), index=False)
    print(f"- Generated calendar.csv with {len(df_calendar)} records.")

    df_customers = simulate_weekly_signups()
    df_customers.to_csv(os.path.join(output_path, "customers.csv"), index=False)
    print(f"- Generated customers.csv with {len(df_customers)} records.")

    df_marketing = simulate_marketing_data()
    df_marketing.to_csv(os.path.join(output_path, "marketing.csv"), index=False)
    print(f"- Generated marketing.csv with {len(df_marketing)} records.")

    df_revenue = simulate_weekly_revenue(df_customers)
    df_revenue.to_csv(os.path.join(output_path, "revenue.csv"), index=False)
    print(f"- Generated revenue.csv with {len(df_revenue)} records.")

    df_product = simulate_product_data(df_customers)
    df_product.to_csv(os.path.join(output_path, "product_usage.csv"), index=False)
    print(f"- Generated product_usage.csv with {len(df_product)} records.")

    df_subscription_changes = simulate_subscription_changes(df_customers)
    df_subscription_changes.to_csv(os.path.join(output_path, "subscription_changes.csv"), index=False)
    print(f"- Generated subscription_changes.csv with {len(df_subscription_changes)} records.")

    df_support_tickets = simulate_support_tickets(df_customers)
    df_support_tickets.to_csv(os.path.join(output_path, "support_tickets.csv"), index=False)
    print(f"- Generated support_tickets.csv with {len(df_support_tickets)} records.")

    print(f"\nAll simulated datasets saved in {output_path}")

    # Load data into SQLite
    print("\nLoading data into SQLite database...")
    sqlite_db_file = CONFIG["SQLITE_DB_PATH"]
    sqlite_dir = os.path.dirname(sqlite_db_file)
    os.makedirs(sqlite_dir, exist_ok=True)
    print(f"Ensuring SQLite directory exists: {sqlite_dir}")

    conn = sqlite3.connect(sqlite_db_file)

    dataframes_to_load = [
        (df_calendar, "calendar"),
        (df_customers, "customers"),
        (df_marketing, "marketing"),
        (df_revenue, "revenue"),
        (df_product, "product_usage"),
        (df_subscription_changes, "subscription_changes"),
        (df_support_tickets, "support_tickets")
    ]

    try:
        for df, table_name in dataframes_to_load:
            df.to_sql(table_name, conn, if_exists="replace", index=False)
            print(f"- Loaded {len(df)} records into '{table_name}' table.")
        
        conn.commit()
        print(f"\nSuccessfully loaded all data into SQLite database: {sqlite_db_file}")
    except Exception as e:
        print(f"Error loading data into SQLite: {e}")
        conn.rollback()
    finally:
        conn.close()
